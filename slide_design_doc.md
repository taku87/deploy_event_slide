==ここは指示です。==
このドキュメントは下記の構造で、プレゼン用のwebページ（スライド）の構成を書いています。
```
# スライド番号
## スライド内容
## スライドイメージ
## 台本
```
スライド内容・スライドイメージに沿ってスライドを作成してください。また、下記を意識してください。
- 直感的に伝わることを意識すること（図解・イラスト・アニメーションを無理ない範囲で活用する）
- 具体的なイメージが湧くこと
- 1つのスライドに文字情報を詰め込みすぎないこと（見辛くなるので）

台本は、下部に目立たない形でカンペとして表示してください。

==ここから構成図です==

# スライド1
## スライド内容
図解でわかる！「デプロイってこういうこと」
## スライドイメージ
タイトルが中央に大きく表示されている。背景には、歯車やコードの断片、ロケットが飛び立つようなイラストが薄く描かれており、「何かを作り上げて公開する」というイメージを表現する。
## 台本
（このスライドはタイトルページのため、台本はなし）

# スライド2
## スライド内容
今日のゴールは
- 「デプロイ」が何かをイメージできるようになる
- 実際のデプロイ作業を行う際に、「今、何をしているか」がわかるようになる
## スライドイメージ
箇条書きの頭にチェックマークやゴールフラッグのアイコンを置く。全体的にポジティブで達成感を感じさせるデザイン。
## 台本
さて、今日は「デプロイ」について学んでいきます。今日のゴールはこちらです。
「アプリ開発はデプロイが山場」という認識を持っている人は結構いるかと思いますが、そもそも「デプロイ」って何をしていることなのか、を学ぶ機会は少ないと感じています。今日はその「なぜ？」を解消していきましょう。

# スライド3
## スライド内容
第1章：そもそも「デプロイ」って何？
## スライドイメージ
章のタイトルが大きく表示された、シンプルなデザイン。
## 台本
では早速、第1章です。まずは「デプロイ」という言葉そのものの意味から見ていきましょう。

# スライド4
## スライド内容
デプロイとは、「開発したアプリケーションを、ユーザーがいつでも使える状態にすること」です。
## スライドイメージ
2つの世界を対比で見せるイラスト。
- 左側（ローカル環境）: 開発者一人がPCを覗き込んでいる。PC画面にはアプリが映っているが、PCと開発者の間だけで閉じた世界になっている。吹き出しで「自分だけがアクセス可能」。
- 右側（本番環境）: インターネットの雲のアイコンの上にサーバーが置かれ、そこから世界中の様々な人々のスマートフォンやPCに線が伸びている。吹き出しで「世界中の人がアクセス可能」。
中央には右向きの大きな矢印があり、「デプロイ」と書かれている。
## 台本
結論から言うと、デプロイとは「開発したアプリケーションを、ユーザーがいつでも使える状態にすること」です。
もう少し具体的に言うと、開発者のコンピューター（ローカル環境）で作成したプログラムやデータを、インターネット上に公開されたサーバー（本番環境）へ配置し、正しく動作するように設定する一連の作業全体を指します。

# スライド5
## スライド内容
サーバーの置き場所も時代と共に変化しています。
## スライドイメージ
- 左側（過去）: 「自社サーバー（オンプレミス）」というタイトルで、サーバーラックがずらりと並んだサーバー室のイラスト。
- 右側（現在）: 「クラウドサービス」というタイトルで、雲のアイコンからサーバーのアイコンが提供されているイラスト。物理的な場所を意識させないイメージ。
## 台本
ここで使われている「サーバー」とは、「アプリケーションを動かすためのコンピューター」のことです。
かつては、多くの企業が自社内にサーバー室を設け、物理的なコンピューターを設置・管理していました。
しかし、クラウドサービスが普及した現在では、そういった物理サーバーを持たずに、クラウド上のサーバーをレンタルして運用することが一般的です。

# スライド6
## スライド内容
「Paas（Platform as a Service）」の登場
アプリケーションを動かすための土台（プラットフォーム）を丸ごと提供してくれるサービス
## スライドイメージ
開発者がアプリケーションのコード（プログラムのアイコン）をPaaS（例：Render）に入れると、PaaSがサーバーの設定や管理を自動的に行い、アプリケーションを公開してくれる、という流れのイラスト。開発者は面倒なサーバー管理から解放されて喜んでいる表情。
## 台本
とはいえ、レンタルしたサーバーの管理には専門知識と手間がかかります。そこで登場したのが、PaaS（Platform as a Service）です。
PaaSを利用することで、開発者はサーバーの管理に煩わされることなく、本来の目的であるアプリケーション開発に集中できるようになります。

# スライド7
## スライド内容
第2章：アプリの構成を見てみよう
## スライドイメージ
章のタイトルが大きく表示された、シンプルなデザイン。
## 台本
次に、私たちが作るアプリケーションが、どのような要素で構成されているかを見ていきましょう。

# スライド8
## スライド内容
シンプルなアプリも、複数のサーバーが連携して動いている！

ユーザー（人のアイコン）
- アプリケーションにアクセスする人

アプリケーションサーバー（Rails）
- リクエストに応じてWebページを作る

データベースサーバー（PostgreSQL）
- 役割：データ倉庫担当
- データを保管・管理する

## スライドイメージ
ユーザー（人のアイコン）、「Appサーバー」（アイコン）、「DBサーバー」（アイコン）が、互いに矢印で通信し合っているイラスト。Appサーバーがユーザーからのリクエストを受け取り、DBサーバーに問い合わせて、結果をユーザーに返している一連の流れが描かれている。
## 台本
私たちが普段何気なく使っているWebサービスは、実は1つのプログラムだけで動いているわけではありません。
例えば、シンプルなブログアプリ（Ruby on Rails製）も、裏側では最低でも2つの役割を持つサーバーが協力し合って動いています。
ユーザーからのリクエストを処理する「頭脳」担当のアプリケーションサーバーと、投稿データなどを保管する「データ倉庫」担当のデータベースサーバーです。

# スライド9
## スライド内容
第3章：アプリ開発の「ローカル環境」とは？
## スライドイメージ
章のタイトルが大きく表示された、シンプルなデザイン。
## 台本
では、こうしたアプリケーションを開発する「場所」について見ていきましょう。第3章はローカル環境についてです。

# スライド10
## スライド内容
開発・テストは、自分のPCで。
この「自分のPC上の開発空間」をローカル環境と呼びます。

「自分だけがアプリにアクセスできる」状態です。正確には、「自分のPCのみ、自分のPC上で動いているアプリケーションにアクセスできる」
## スライドイメージ
開発者（人のアイコン）が自分のPCの前に座り、集中してコーディングしているイラスト。PCの画面には、まだ外部には公開されていない開発中のアプリケーションが映っている。思考の吹き出しの中に、バグ修正や機能追加のアイデアが描かれている。
## 台本
さて、いきなり本番のサーバーにデプロイするわけではありません。まずは自分のPC上でアプリケーションを開発し、テストを繰り返します。この「自分のPC上の開発空間」のことをローカル環境（または開発環境）と呼びます。
このローカル環境を作る方法にも、いくつかやり方があります。まずは、昔ながらのオーソドックスな方法を見てみましょう。

# スライド11
## スライド内容
昔ながらの方法：PCに直接ツールをインストールする
## スライドイメージ
PCのイラストの中に、Ruby、Rails、PostgreSQLなど、様々なツールのロゴが直接インストールされていくアニメーション風のイラスト。
## 台本
これは、アプリケーションを動かすのに必要なツール（プログラミング言語であるRuby、フレームワークのRails、データベースのPostgreSQLなど）を、すべて自分のPCに一つひとつインストールしていく方法です。

# スライド12
## スライド内容
直接インストール方式の「落とし穴」①
環境の違いで動かない！
## スライドイメージ
2人の開発者が困った顔で向かい合っている。
- AさんのPC画面ではアプリが正常に動いている（緑のチェックマーク）。
- BさんのPC画面ではエラーメッセージが表示されている（赤のバツ印）。
2人のPCの間には「OS?」「バージョン?」といったハテナマークが飛んでいる。
## 台本
一見シンプルに見えるこの「直接インストール方式」ですが、実は多くの開発者を悩ませる「落とし穴」があります。
一つ目は、環境の違いで動かなくなる問題です。チームで開発していると、「AさんのPCでは動くのに、BさんのPCでは原因不明のエラーが出る…」という事態が頻繁に起こります。これは、PCのOSの違いや、インストールされているツールのバージョンが微妙に違うこと（環境差異）が原因です。

# スライド13
## スライド内容
直接インストール方式の「落とし穴」②
PCがごちゃごちゃになる
## スライドイメージ
PCの中が、様々なバージョン番号が書かれたツールのアイコンで溢れかえり、カオスになっているイラスト。「Project A (Ruby 2.7)」「Project B (Ruby 3.0)」といったラベルが貼られたアイコンが混在している

「アプリBを開発した後にアプリAに戻ると、『あれ、昨日まで動いてたアプリAが動かない…なぜ！？』」という状況を表現。
## 台本
二つ目は、PCがごちゃごちゃになる問題です。
新しいプロジェクトを始めるたびに、新しいツールや違うバージョンのツールをPCにインストールしていくと、PCの中はどんどんカオスな状態になります。「プロジェクトAではRuby 2.7、プロジェクトBではRuby 3.0が必要…」といったバージョン管理は非常に面倒です。

# スライド14
## スライド内容
直接インストール方式の「落とし穴」③
本番環境とのギャップ
## スライドイメージ
開発者のPC（macOSのロゴ）から本番サーバー（Linuxのペンギンのロゴ）へ、アプリをデプロイする矢印。しかし、サーバーに到達した瞬間にアプリが「ERROR」と表示されて壊れてしまうイラスト。開発者は頭を抱えている。
## 台本
そして、一番の問題はこれです。
自分のPC（macOS）で完璧に動くことを確認したのに、本番サーバー（多くはLinux）にデプロイした瞬間にエラーで動かなくなる、という悲劇です。これもOSやツールのバージョンの違いが引き起こします。

# スライド15
## スライド内容
第5章：そこで登場！救世主「Docker」
## スライドイメージ
Dockerのロゴをシンプルに表示する。
## 台本
これまでの問題を一気に解決してくれる現代の必須ツールが「Docker」です。

# スライド16
## スライド内容
Dockerとは、「アプリケーションを動かすのに必要な環境を、まるごと詰め込める魔法の箱（＝コンテナ）を作るためのツール」です。
## スライドイメージ
「魔法の箱（コンテナ）」のイラスト。箱の中には「OS」「ライブラリ」「アプリ」と書かれたブロックが整然と詰め込まれている。箱には持ち運びしやすいように取っ手がついている。
## 台本
Dockerをひとことで説明するなら、このようになります。アプリケーションとその実行環境をセットで「箱詰め」にしてしまうイメージです。

# スライド17
## スライド内容
メリット①：誰でも全く同じ環境を再現できる
## スライドイメージ
「設計図（Dockerfile）」と書かれたドキュメントのようなイラスト。そこから全く同じ「コンテナ」の箱が複数コピーされて作られて、いろんな人がそれぞれの箱を使っているイラスト。AさんのPCでは正常に動いている（緑のチェックマーク）、BさんのPCでも同じように動いている（緑のチェックマーク）。
## 台本
この「コンテナ」という箱を使えば、こんないいことがあります。まず1つ目。
コンテナの「設計図（Dockerfile）」さえ共有すれば、誰でも全く同じ環境の箱を数分で作れます。これにより、「AさんのPCでは動くのに、BさんのPCでは動かない」といった環境差異の問題が解決されます。

# スライド18
## スライド内容
メリット②：PC本体はいつもクリーン
## スライドイメージ
PCのイラスト。その周りを複数の「コンテナ」の箱が浮いている。PC本体には何もインストールされておらず、クリーンな状態を表現。プロジェクトが終わったら、該当する箱にゴミ箱マークがついて消えていくアニメーション。
## 台本
メリットの2つ目です。
アプリケーションに必要なツールは、すべて箱の中に隔離されています。そのため、新しいプロジェクトのためにPC本体に色々なツールをインストールする必要がなくなり、PCをいつもクリーンな状態に保てます。プロジェクトが終われば、箱ごと削除するだけです。

# スライド19
## スライド内容
メリット③：本番環境にもそのまま持っていける
## スライドイメージ
開発者のPC（ローカル環境）にある「コンテナ」の箱が、ベルトコンベアのようなもので「サーバー（本番環境）」へと運ばれていき、そのままサーバー上で動き出すイラスト。
## 台本
そして3つ目のメリットです。
開発で使った「箱」を、そのまま本番サーバーに持っていくことができます。ローカル環境と本番環境のギャップが最小限になり、「ローカルでは動いたのに本番では動かない」という悲劇が起こる可能性が格段に下がります。

# スライド20
## スライド内容
第6章：なぜデプロイで詰まる？ローカルと本番の3つの「壁」
## スライドイメージ
開発者が、目の前に立ちはだかる巨大な3つの壁（レンガ造り）を見上げているイラスト。壁にはそれぞれ「DB設定」「機密情報」「ネットワーク」と薄く書かれている。
## 台本
「ローカルでは完璧に動いたのに、いざデプロイしたらエラーの嵐…」
これは、Dockerを使っていても起こりうる、多くの開発者が経験する壁です。なぜ、このようなことが起きるのでしょうか？その原因は、たとえDockerを使っていても残ってしまう、ローカル環境と本番環境の「見えない違い」にあります。
デプロイで立ちはだかる「3つの壁」を予め見ていきましょう。

# スライド21
## スライド内容
壁①：DB設定の壁
- ローカルでは… 自分のPC内（localhost）で手軽に動かす。
- 本番では… 性能やセキュリティのため、専用の別サーバーで動かす。
- ここで詰まる！ ローカルの設定のままデプロイし、本番DBに接続できずエラーになる。
## スライドイメージ
- ローカル: 1台のPCのイラストの中に「App」と「DB」があり、短い矢印で繋がっている図。
- 本番: 「Appサーバー」と「DBサーバー」という2台のサーバーのイラストがあり、長い矢印で繋がっている図。矢印は点線や赤色になっており、接続が不安定・困難であることを示す。
## 台本
1つ目の壁は、データベース設定の違いです。
- ローカルでは… 手軽さを重視し、DBサーバーも自分のPC内で動かします。`compose.yml`で`host: db`と書くだけで簡単に接続できました。
- 本番では… 性能やセキュリティのため、Appサーバーとは別の専用サーバーでDBを動かします。
- ここで詰まる！ ローカルの接続設定のままデプロイしてしまい、本番DBに接続できずエラーになります。本番用のDBの正しい接続先を指定し直す必要があります。

# スライド22
## スライド内容
壁②：機密情報・環境変数の壁
- ローカルでは… DBのパスワードなどを、便宜上ファイルで管理する。
- 本番では… 機密情報をファイルで置くのは絶対にNG！サーバーの機能（環境変数）で安全に管理する。
- ここで詰まる！ ローカルのファイルに頼ったコードのままデプロイし、機密情報を読み込めずエラーになる。
## スライドイメージ
- ローカル: 「master.key」と書かれたファイルがPCのイラスト内に無造作に置かれている図。
- 本番: 「環境変数」と書かれた金庫の中に「鍵マーク」が安全に保管されているイラスト。コードとは別の場所で厳重に管理されていることを示す。
## 台本
2つ目の壁は、パスワードなどの機密情報の管理方法の違いです。
- ローカルでは… DBのパスワードや外部サービスのAPIキーといった機密情報を、便宜上、`config/master.key`や`.env`といったファイルで管理します。
- 本番では… 絶対にやってはいけないこと、それは機密情報をファイルとしてサーバーに置くことです。コードが漏洩した際に、すべての機密情報が流出してしまいます。本番環境では、サーバーの機能（環境変数）を使って、コードとは分離された安全な場所で機密情報を管理します。
- ここで詰まる！ ローカルのファイルに頼ったコードのままデプロイすると、本番環境では機密情報を読み込めず、DB接続エラーやAPI認証エラーが発生します。

# スライド23
## スライド内容
壁③：ネットワークの壁
- ローカルでは… 基本的にPC内の通信は自由。
- 本番では… ファイアウォール（防火壁）で、許可された通信以外はすべてブロックされる。
- ここで詰まる！ 外部APIへの通信がファイアウォールに阻まれ、タイムアウトエラーになることがある。
## スライドイメージ
サーバーのイラストが「ファイアウォール」というレンガの壁で囲まれている。Webページを見るための通信（HTTP/HTTPS）だけが通れる小さな門があり、それ以外の通信（外部APIなど）は壁にぶつかって跳ね返されているイラスト。
## 台本
3つ目の壁は、ネットワーク、特にファイアウォールの存在です。
- ローカルでは… 基本的にPC内の通信は自由です。ファイアウォールを意識することはほとんどありません。
- 本番では… サーバーは不正アクセスを防ぐため、ファイアウォールという「防火壁」で厳重に守られています。Webページを見るための通信（HTTP/HTTPS）など、許可された通信以外はすべてブロックされます。
- ここで詰まる！ アプリケーションが外部のAPIを利用しようとしたら、本番サーバーのファイアウォール設定で外部への通信が許可されておらず、接続タイムアウトエラーになることがあります。

# スライド24
## スライド内容
第7章：実践編：Renderデプロイで「3つの壁」を乗り越える
## スライドイメージ
Renderのロゴと、先ほどの「3つの壁」を乗り越えていく人のシルエットを組み合わせたイラスト。
## 台本
お疲れ様です！第6章まででデプロイの難しさの正体がわかりましたね。
この章では、実際にPaaSである「Render」へデプロイする際に、ローカルのDocker環境と何が違い、なぜ「あの設定」が必要だったのかを一つずつ解き明かしていきます。

# スライド25
## スライド内容
ポイント1：ビルドと起動の分離 → `render-build.sh`の役割
- ローカルでは: `docker compose up`一発で完了。
- Renderでは: 「ビルド（準備）」と「起動（サービス提供）」を明確に区別する。
  - Build Command: デプロイ時に1回だけ実行される準備命令。
  - Start Command: サーバーを起動し続ける命令。
## スライドイメージ
シンプルなフロー図。
「デプロイ」というトリガーから矢印が2つに分岐。
- 1つは「Build Command（準備）」へ。歯車のアイコン。
- もう1つは「Start Command（起動）」へ。再生ボタンのアイコン。
## 台本
- ローカル(Docker)では: `docker compose up`というコマンド一発で、環境構築からRailsサーバーの起動まで全部やってくれました。
- Renderでは: Renderは「ビルド（準備作業）」と「起動（サービス提供）」を明確に区別します。
  - Build Command (`./bin/render-build.sh`): デプロイ時に一度だけ実行される「準備用の命令」です。`bundle install`や`db:migrate`といった、アプリを動かすための下準備をここで行います。
  - Start Command (`bundle exec rails server`): ビルド完了後、Webサーバーを起動し続けるための命令です。ユーザーからのアクセスを待ち受けるのがこちらの役割です。
- なぜ必要？ この分離により、デプロイのたびに毎回必要な準備作業だけを効率的に行い、サービスをスムーズに更新できるのです。

# スライド26
## スライド内容
ポイント2：データベースは別サービス → `DATABASE_URL`の役割
- ローカルでは: Webサーバーの「隣」にDBがいた。
- Renderでは: 完全に独立したDB専門サービスを利用する。
- `DATABASE_URL` は、その本番DBの「住所録」。
## スライドイメージ
- ローカル: 「Webコンテナ」と「DBコンテナ」が隣り合って仲良く並んでいるイラスト。
- Render: 「Web Service」と、少し離れた場所にある「PostgreSQL Service」が、「DATABASE_URL」と書かれた矢印でしっかり結ばれているイラスト。
## 台本
- ローカル(Docker)では: Webサーバーのコンテナの「隣」にDBコンテナがいました。
- Renderでは: Web Serviceとは完全に独立したPostgreSQLという「データベース専門サービス」を別途作成しました。これは「DB設定の壁」を乗り越えるための重要なステップです。
- なぜ必要？ ローカルのDBをそのまま本番で使うわけにはいきません。Renderが用意した、より安全で高性能な本番用DBに接続し直す必要があります。そのための「本番DBの住所録」が、環境変数`DATABASE_URL`です。Railsはこの環境変数を見つけると、`database.yml`の設定よりも優先して、正しい本番DBに接続しにいきます。

# スライド27
## スライド内容
ポイント3：機密情報はコードに含まない → `RAILS_MASTER_KEY`の役割
- ローカルでは: `master.key`はファイルとして存在した。
- Renderでは: ファイルは存在しない。代わりに環境変数で鍵を渡す。
- これで「機密情報の壁」を安全に突破！
## スライドイメージ
Renderのダッシュボード画面のイラスト。フォームに「RAILS_MASTER_KEY」という環境変数を入力している様子。その値が、サーバー上の「鍵穴」にカチッとはまり、ロックが解除されるアニメーション風のイラスト。
## 台本
- ローカル(Docker)では: `config/master.key`はPC内にファイルとして存在していました。
- Renderでは: `.gitignore`により`master.key`はGitHubに存在しないため、Renderもこのファイルを知りません。
- なぜ必要？ そこで登場するのが環境変数`RAILS_MASTER_KEY`です。Renderのダッシュボード画面でこの値を設定することで、コードには含めずに、安全に鍵を本番サーバーにだけ渡すことができます。これにより「機密情報・環境変数の壁」を安全に乗り越えることができるのです。

# スライド28
## スライド内容
まとめ：デプロイを制して、開発をもっと楽しく！
- デプロイとは、アプリを世界に公開する作業。
- ローカルと本番には「DB設定」「機密情報」「ネットワーク」という「壁」がある。
- `render-build.sh`や環境変数は、この「壁」を乗り越えるための重要な手続き。
## スライドイメージ
紙吹雪が舞う中で、開発者がガッツポーズをしているイラスト。「Deployment Complete!」という文字が輝いている。
## 台本
ここまでお疲れ様でした！最後に、今回の内容を振り返ってみましょう。
- デプロイとは、開発したアプリケーションを世界に公開するための作業です。
- ローカル環境（自分のPC）と本番環境（サーバー）には、「DB設定」「機密情報の管理」「ネットワーク」など、いくつもの「違い（壁）」が存在します。
- `render-build.sh`や環境変数の設定は、これらの「壁」を乗り越え、ローカルと本番の違いを吸収するための非常に重要な手続きです。

# スライド29
## スライド内容
自分の作ったサービスが、世界中の誰かに使われる感動を。
## スライドイメージ
世界地図が描かれたモニターを、開発者が誇らしげに眺めているイラスト。地図上には、世界中からサービスへアクセスしていることを示す線が描かれている。
## 台本
デプロイは、決して魔法ではありません。ローカルと本番の違いを正しく理解し、一つひとつの設定を丁寧に行うことで、誰でも乗り越えることができます。
そして、自分の作ったサービスがインターネット上で動き出し、世界中の誰かがアクセスしてくれた時の感動は、何物にも代えがたいものです。
このページで得た知識を元に、ぜひあなた自身のアプリケーションのデプロイに挑戦してみてください！
